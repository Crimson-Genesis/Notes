# 1. Difference in ACID and CAP
# Answer:- 

## **1. ACID Properties (Traditional Databases)**

ACID is a set of properties that guarantee **reliable transactions** in a database system.

* **A ‚Äì Atomicity**:
  A transaction is "all or nothing". If any part fails, the whole transaction rolls back.
  üëâ Example: Money transfer ‚Äî if debit succeeds but credit fails, rollback happens.

* **C ‚Äì Consistency**:
  A transaction brings the database from one **valid state to another valid state**, maintaining integrity constraints.
  üëâ Example: Balance cannot go negative if constraints exist.

* **I ‚Äì Isolation**:
  Transactions appear to run **independently**, even if executed concurrently.
  üëâ Example: Two people booking the last movie ticket ‚Äî only one succeeds.

* **D ‚Äì Durability**:
  Once a transaction commits, its result is **permanent**, even in case of system crash.
  üëâ Example: After payment is made, the order should remain recorded even after server reboot.

üîë **Goal of ACID** ‚Üí Ensure correctness, reliability, and trustworthiness of transactions.
Mostly used in **centralized / relational DBMS**.

---

## **2. CAP Theorem (Distributed Databases)**

CAP theorem is about **trade-offs in distributed systems** (proposed by Eric Brewer).

It states:
üëâ In a distributed database, you can only guarantee **2 out of 3**:

* **C ‚Äì Consistency**:
  All nodes see the same data at the same time.
  üëâ Example: If you write `X=5`, every replica immediately sees `X=5`.

* **A ‚Äì Availability**:
  Every request gets a **response**, even if some nodes are down.
  üëâ Example: Amazon always responds, even if some servers are failing.

* **P ‚Äì Partition Tolerance**:
  The system continues to function even if communication between nodes is broken.
  üëâ Example: Even if a network link between two data centers fails, system keeps running.

üîë **Goal of CAP** ‚Üí Decide what to sacrifice when a network partition happens.

* CP systems ‚Üí Strong consistency, but may be unavailable during partition (e.g., traditional RDBMS clusters).
* AP systems ‚Üí High availability, but eventual consistency (e.g., DynamoDB, Cassandra).

---

## **3. Key Differences**

| Aspect          | ACID (Traditional DB)                         | CAP Theorem (Distributed DB)                   |
| --------------- | --------------------------------------------- | ---------------------------------------------- |
| Focus           | Transaction reliability                       | Trade-off in distributed systems               |
| Origin          | Database theory (1970s)                       | Eric Brewer‚Äôs theorem (2000)                   |
| Properties      | Atomicity, Consistency, Isolation, Durability | Consistency, Availability, Partition Tolerance |
| Application     | Centralized relational databases              | Distributed & NoSQL databases                  |
| Trade-off?      | No, aims to provide all four                  | Yes, can only guarantee 2 out of 3             |
| Example Systems | Oracle, MySQL (InnoDB), PostgreSQL            | MongoDB, Cassandra, DynamoDB, HBase            |

---

* **ACID** ensures that each transaction is correct and reliable.
* **CAP** explains why distributed databases can‚Äôt have everything (Consistency, Availability, Partition tolerance) at once.

---

# 2. Difference in intent lock and update lock
# Answer:- 

# **1. Intent Lock (IL)**

* **Definition**: A **meta-lock** used in hierarchical locking (table ‚Üí page ‚Üí row).
* **Purpose**: Shows a transaction‚Äôs **intention to acquire** a more specific lock (Shared or Exclusive) at a lower level in the hierarchy.
* **Types**:

  * **IS (Intent Shared)** ‚Üí Transaction intends to acquire Shared lock at finer granularity.
  * **IX (Intent Exclusive)** ‚Üí Transaction intends to acquire Exclusive lock at finer granularity.
  * **SIX (Shared + Intent Exclusive)** ‚Üí Transaction has a Shared lock but intends Exclusive locks below.
* **Why needed?**

  * Prevents conflicts when multiple transactions lock at different granularities.
  * Example: If one transaction locks a **table** in `IS`, another can still read rows but not take exclusive control.

üëâ **Example**:

* Transaction T1: ‚ÄúI want to read some rows in the `Employee` table.‚Äù ‚Üí Puts **IS** on table, then `S` on rows.
* Transaction T2: ‚ÄúI want to update some rows.‚Äù ‚Üí Puts **IX** on table, then `X` on rows.

---

# **2. Update Lock (U)**

* **Definition**: A **special lock** used to avoid **deadlock** when upgrading from `Shared (S)` to `Exclusive (X)`.
* **Purpose**: Ensures that only **one transaction** can hold an Update lock at a time on an item.
* **Why needed?**

  * Without U-lock, two transactions could both read with `S` lock and later both try to upgrade to `X` lock ‚Üí **deadlock**.
* **Behavior**:

  * A `U` lock is **compatible with S** (others can still read).
  * When transaction decides to update ‚Üí `U` ‚Üí `X`.

üëâ **Example**:

* T1 reads a row (gets `U` lock).
* T2 can still read with `S`.
* When T1 updates, it upgrades `U ‚Üí X`.
* Prevents both T1 & T2 from being stuck waiting for each other.

---

# **3. Key Differences**

| Aspect               | **Intent Lock (IL)**                               | **Update Lock (U)**                             |
| -------------------- | -------------------------------------------------- | ----------------------------------------------- |
| **Purpose**          | Shows intention to acquire lower-level locks       | Prevents deadlock when upgrading from `S` ‚Üí `X` |
| **Granularity**      | Works in hierarchical locking (table ‚Üí page ‚Üí row) | Works at single data item level                 |
| **Types**            | IS, IX, SIX                                        | Only one type (`U`)                             |
| **Compatibility**    | Compatible with some locks depending on type       | Compatible with `S`, not with `X`               |
| **When used**        | Before placing `S` or `X` locks at finer levels    | When transaction may change from read ‚Üí write   |
| **Example Use Case** | Table-level intention before row locks             | Row-level read-then-update                      |

---

‚úÖ **In short**:

* **Intent Lock** = ‚ÄúI plan to lock something below this level.‚Äù
* **Update Lock** = ‚ÄúI might update later, so reserve upgrade rights to avoid deadlock.‚Äù

# 3. Explain the various evaluation measures of search relevance using example.
# Answer:- 

# **Evaluation Measures of Search Relevance**

When we perform a search (like Google, database queries, or search engines), we want to **evaluate how relevant the retrieved results are** compared to the user‚Äôs query.
The main measures come from **Information Retrieval theory**.

---

## **1. Precision**

* **Definition**: Fraction of retrieved documents that are **relevant**.
* Formula:

  $$
  Precision = \frac{\text{Relevant documents retrieved}}{\text{Total documents retrieved}}
  $$
* **Example**:

  * Query returns **10 documents**.
  * Out of them, **7 are relevant**.
  * Precision = 7/10 = **0.7 (70%)**.
* **Meaning**: High precision ‚Üí few irrelevant results.

---

## **2. Recall**

* **Definition**: Fraction of all relevant documents that are successfully retrieved.
* Formula:

  $$
  Recall = \frac{\text{Relevant documents retrieved}}{\text{Total relevant documents in collection}}
  $$
* **Example**:

  * There are **20 relevant documents** in the whole database.
  * Query retrieves **7 of them**.
  * Recall = 7/20 = **0.35 (35%)**.
* **Meaning**: High recall ‚Üí system finds most of the relevant items.

---

## **3. F-measure (or F1 Score)**

* **Definition**: Harmonic mean of Precision and Recall.
* Formula:

  $$
  F1 = 2 \times \frac{Precision \times Recall}{Precision + Recall}
  $$
* **Example**:

  * Precision = 0.7, Recall = 0.35
  * F1 = 2 √ó (0.7 √ó 0.35) / (0.7 + 0.35) = **0.47**
* **Meaning**: Balances both Precision & Recall.

---

## **4. Precision\@k (P\@k)**

* **Definition**: Precision of the **top k results**.
* Formula:

  $$
  P@k = \frac{\text{Relevant documents in top k}}{k}
  $$
* **Example**:

  * User checks **top 5 results**.
  * 4 out of 5 are relevant.
  * P\@5 = 4/5 = **0.8**.
* **Meaning**: Important in real-world (since users don‚Äôt check all results).

---

## **5. Mean Average Precision (MAP)**

* **Definition**: Average precision across multiple queries.
* Formula:

  $$
  MAP = \frac{\sum_{q=1}^{Q} AveragePrecision(q)}{Q}
  $$
* **Example**:

  * Query 1 AP = 0.6
  * Query 2 AP = 0.8
  * MAP = (0.6 + 0.8) / 2 = **0.7**.
* **Meaning**: Useful for system-wide evaluation across queries.

---

## **6. Discounted Cumulative Gain (DCG) & NDCG**

* **Definition**: Measures ranking quality by giving **higher weight to relevant documents appearing earlier**.
* Formula (DCG at position *p*):

  $$
  DCG_p = \sum_{i=1}^{p} \frac{rel_i}{\log_2(i+1)}
  $$

  where `rel_i` = relevance score at position *i*.
* **Normalized DCG (NDCG)** = DCG / Ideal DCG.
* **Example**:

  * Top 3 results relevance scores = \[3, 2, 1]
  * DCG = 3/ log‚ÇÇ(2) + 2/log‚ÇÇ(3) + 1/log‚ÇÇ(4) = 3/1 + 2/1.58 + 1/2 = **4.76**
  * NDCG compares this with the **best possible ranking**.
* **Meaning**: Captures both relevance and ranking order.

---

## **7. Mean Reciprocal Rank (MRR)**

* **Definition**: Measures how quickly the first relevant result is found.
* Formula:

  $$
  MRR = \frac{1}{Q} \sum_{q=1}^{Q} \frac{1}{rank_q}
  $$
* **Example**:

  * Query 1 ‚Üí first relevant result at rank 2 ‚Üí 1/2 = 0.5
  * Query 2 ‚Üí first relevant result at rank 1 ‚Üí 1/1 = 1
  * MRR = (0.5 + 1) / 2 = **0.75**.
* **Meaning**: High MRR = users find relevant info faster.

---

# ‚úÖ Summary Table

| Measure       | Focus                                     | Example    |
| ------------- | ----------------------------------------- | ---------- |
| **Precision** | How many retrieved are relevant           | 7/10 = 70% |
| **Recall**    | How many relevant are retrieved           | 7/20 = 35% |
| **F1-score**  | Balance of precision & recall             | 0.47       |
| **P\@k**      | Precision in top-k results                | P\@5 = 0.8 |
| **MAP**       | Avg. precision across queries             | 0.7        |
| **DCG/NDCG**  | Ranking quality (early relevance matters) | 4.76       |
| **MRR**       | Position of first relevant result         | 0.75       |

---

‚úÖ **In short**:

* **Precision & Recall** ‚Üí Accuracy of retrieval.
* **F1** ‚Üí Balance.
* **P\@k & MAP** ‚Üí Ranking-based user satisfaction.
* **DCG/NDCG & MRR** ‚Üí Ranking quality & speed of finding relevant results.

# 4. Discuss primary, secondary, and clustring indexs
# Answer:- 

# **1. Primary Index**

* **Definition**: An index built on a table‚Äôs **primary key (or unique key)**, where data records are stored in the **same order** as the index.
* **Characteristics**:

  * Ordered on the primary key field.
  * Each record appears **exactly once** in the index.
  * Index entries point directly to the data blocks.
* **Example**:
  Suppose we have a table `Student(RollNo, Name, Marks)` with `RollNo` as primary key.

  * The **primary index** is built on `RollNo`.
  * If `RollNo` is sorted in data file (10, 20, 30, ‚Ä¶), index entries follow the same order.
* **Use**: Fast access when searching by primary key.

---

# **2. Secondary Index**

* **Definition**: An index built on **non-primary key attributes** (candidate key or non-key).
* **Characteristics**:

  * Provides **alternative search paths**.
  * Records are **not stored in the order** of secondary key.
  * May require **extra storage** since duplicates are possible.
* **Example**:
  Continuing with `Student(RollNo, Name, Marks)`:

  * If we create an index on `Name`, it‚Äôs a **secondary index** (since Name is not the primary key).
  * Data file remains ordered by `RollNo`, not by `Name`.
* **Use**: Useful for queries like `SELECT * FROM Student WHERE Name = 'Rahul';`

---

# **3. Clustering Index**

* **Definition**: An index where the **ordering of data records** in the table is **based on a non-primary attribute (clustering field)**.
* **Characteristics**:

  * Records with the same clustering field value are stored **together**.
  * One clustering index per table (like primary index).
  * Helps when range queries are frequent.
* **Example**:
  In `Student(RollNo, Dept, Marks)`:

  * If students are **physically stored by Dept** (all CS together, then ECE, then ME), then an index on `Dept` is a **clustering index**.
  * All `CS` records are in adjacent blocks.
* **Use**: Efficient for queries like `SELECT * FROM Student WHERE Dept = 'CS';`

---

# ‚úÖ **Comparison Table**

| Feature             | Primary Index             | Secondary Index           | Clustering Index           |
| ------------------- | ------------------------- | ------------------------- | -------------------------- |
| Based on            | Primary key               | Non-primary key           | Non-primary attribute      |
| Order of data file  | Sorted by primary key     | Not sorted by index field | Sorted by clustering field |
| Duplicates allowed? | No                        | Yes                       | Yes (grouped)              |
| Number per table    | One (only on primary key) | Many allowed              | One                        |
| Example             | Index on RollNo           | Index on Name             | Index on Dept              |

---

‚úÖ **In short**:

* **Primary index** ‚Üí Built on primary key, ordered storage.
* **Secondary index** ‚Üí Built on non-primary key, provides extra search path.
* **Clustering index** ‚Üí Built on non-key field, records grouped together physically.

# 5. Explain the architecture for lock in scheduler in transaction processing Management.
# Answer:- 

# üîë **1. Role of a Scheduler**

* In transaction management, **Scheduler** decides the order of operations from different transactions to ensure:

  * **Serializability** (execution equivalent to serial order)
  * **Concurrency** (multiple transactions running together)
  * **No anomalies** (lost update, dirty read, etc.)

When we use **Locking Protocols (like 2-Phase Locking)**, the scheduler enforces correctness by controlling locks.

---

# üîë **2. Architecture for Lock-based Scheduler**

The architecture has the following **main components**:

### **(a) Transaction Manager**

* Accepts transactions (with operations like `read(x)`, `write(x)`).
* Sends lock requests to the **Lock Manager** before accessing data items.
* Ensures each transaction follows ACID properties.

---

### **(b) Lock Manager**

* Central module responsible for **granting and releasing locks**.
* Maintains a **Lock Table** with entries:

  * **Data Item ID**
  * **Lock Type (Shared, Exclusive, Intent, Update, etc.)**
  * **Transaction holding the lock**
  * **Queue of waiting transactions**

**Functions:**

1. When a transaction requests a lock:

   * If **compatible** ‚Üí grant lock.
   * If **conflict** ‚Üí transaction is **blocked** (waits).
2. On unlock, waiting transactions are checked and granted locks if possible.

